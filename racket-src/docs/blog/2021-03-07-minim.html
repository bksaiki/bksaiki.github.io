<!doctype html>
<html><head><meta charset="utf-8"/><title>Brett Saiki</title><link rel="icon" type="image/png" href="../resources/favicon.ico"/><link rel="stylesheet" type="text/css" href="../main.css"/><link rel="stylesheet" type="text/css" href="../blog.css"/></head><body><div id="main-section"><div id="header"><h2 id="header-title">Brett Saiki</h2></div><div id="back-button"><p><a href="../blog.html">&lt; Back</a></p></div><h3>Developing Minim</h3><div class="section-body"><h4 class="blog-header">March 07, 2021
</h4><div class="blog-body"><p>Recently, I released version 0.2.0 of <a href="https://github.com/bksaiki/Minim">Minim</a>, my hobby-language that I&rsquo;ve been developing since last fall. It&rsquo;s inspired by my time working with Racket (now more than a year). Despite having no formal experience with programming languages, I&rsquo;ve made quite a bit of progress, although I still have lots to learn. Here are a few of my thoughts from developing the language.</p><h4 id="from-static-to-dynamic-types">From Static to Dynamic Types</h4><p>My language of choice for developing Minim is C. Not the best choice for a smooth experience, but it&rsquo;s been quite interesting. The most annoying part is obviousing dealing with pointers;  nearly every bug I&rsquo;ve run into is a segmentation fault. The most interesting concept, however, is the interaction of Minim&rsquo;s dynamic  type system with C&rsquo;s static type system.</p><p>Mainly, how do you define a dynamic type system in a language  that is statically typed, especially without classes like  in C++ or Java? The best solution that I&rsquo;ve found is void pointers and enums.  Intuitively, store a void pointer and an enumerated value such  that the value hints at what is stored at the pointer. With this method, we can store anything from an integer to  a string in a unified object, or the <code>MinimObject</code> in the  case of the Minim language. Minim can easily verify the type  of inputs when invoking a function and can throw an error when necessary.</p><p>Of course, all of this is abstracted away when running Minim. The user can still identify the type of an object with procedures  such as <code>number?</code> or <code>string?</code>, but they need not worry about  its initialization, storage, and deletion. An added benefit is multiple types of objects can be stored  in the same list such as <code>(list 1 'a "str")</code>. This concept may be trivial, but it is quite interesting to see  that a simple construct can do away with the restrictions  of statically-typed code.</p><h4 id="parsing-parsing-parsing">Parsing, Parsing, Parsing</h4><p>The worst experience, by far, has been figuring out how  to parse an input string without any fancy libraries. For the most part, if we can munge the string,  it&rsquo;s not too awful. Split the string by looking for spaces and parentheses/brackets. New lines and tabs are really just spaces in Minim,  so they&rsquo;re not too useful like Python. All we have to do is keep track of quoted strings,  Lisp-style quotes, and comments.</p><p>Unfortunately with version 0.2.0, Minim supports executing  expressions from a file, and errors without syntax  information are quite unhelpful. Therefore, we need to store the syntax information of where  expressions and functions are located. We can&rsquo;t munge the string before parsing since we lose  information about row and column numbers of characters. We must (a) track row and column information,  (b) ignore distracting whitespace, and  (c) still tokenize words. I managed to pull it with a reader thats around  200 lines long and a parser of similar length,  but it&rsquo;s quite a mess.</p><p>Nevertheless, the results have been impressive. Backtraces from errors are quite detailed and they  print out &ldquo;stack frames&rdquo; with the following format:  <code>&lt;file&gt; &lt;row&gt;:&lt;col&gt; &lt;name&gt;</code>. It&rsquo;s crudeness will definitely be a problem in the future,  but for now it works.</p><h4 id="problems-to-come">Problems to Come</h4><p>The most broken part of Minim is the blurry  distinction between owners and references,  and the lack of separation between mutable  and immutable objects.</p><p>The first problem borrows a concept from C++. In brief, certain objects are the original owners  of their information. It&rsquo;s better to pass a reference of that object  to a function rather than the entire copy since  it takes less space and is less cumbersome than  pointers that are dominant in C. Minim also implements this system, since it&rsquo;s less  resource intensive to <em>not</em> copy lists every time  we use them for read-only purposes. However, without a static type system, the use for  this is more subtle. Every built-in function in Minim needs to have  two separate cases for owners and references,  and this parallel strategy causes many issues.  It&rsquo;s not ideal, but it seems to work.</p><p>The second problem is a distinction that Racket makes clear:  there are immutable objects and there are mutable objects. In Racket, the two different types of objects each have  their own set of procedures. Initially, I chose not to care since it seemed  cumbersome to have two sets of procedures. Invoking an in-place update of <em>any</em> hash  table seemed reasonable, but it&rsquo;s problematic  with function calls and references. There are a number of examples that I can think of  that will break Minim.</p><h4 id="conclusion-and-future-work">Conclusion and Future Work</h4><p>Although, I spent much of this blog talking about  what is bad, there has been a lot of good. Most importantly,  I&rsquo;ve learned quite a bit about developing something  as complex as a &ldquo;lightweight&rdquo; programming language. As of the time I&rsquo;m writing this, the repository is  well over 10,000 lines of code and the language  contains over 120 procedures and numerous types  like lists, strings, hash tables, vectors, and more.</p><p>In the next update, there will be considerably more  procedures in the &ldquo;standard library&rdquo; I&rsquo;ve been developing. They will mostly include math functions like <code>gcd</code> and <code>lcm</code>. More list procedures are a must since lists form the backbone  of any Lisp/Scheme language. Additionally, I need to resolve the issues mentioned above  as well as making procedures proper closures  (storing the environment from which they were created).</p><p>This blog was long-winded mostly because there  was a lot to talk about. I hope to write more about Minim in the near future as  it develops from the small fledgling it is today to  a language that is full and robust. Stay tuned for more.</p><div id="postscript"><p>Last updated: March 28, 2021
</p><p>This work is licensed under a <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p></div></div></div></div></body></html>